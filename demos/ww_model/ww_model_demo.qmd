---
title: "Replicating model fitting hospital admissions and waste water data from ww-inference-model"
format: gfm
engine: jupyter
---

```{python}
# | label: setup
import json
import jax
import jax.numpy as jnp
import numpyro
import numpyro.distributions as dist
import numpyro.distributions.transforms as transforms
from pyrenew.deterministic import DeterministicVariable, DeterministicPMF

from pyrenew.randomvariable import DistributionalVariable, TransformedVariable
from pyrenew_hew.ww_site_level_dynamics_model import ww_site_level_dynamics_model
from pyrenew_hew.utils import convert_to_logmean_log_sd
import pyrenew_hew.plotting as plotting

numpyro.set_host_device_count(4)
```

We will use the data used in the `wwinference` [vignette](https://github.com/CDCgov/ww-inference-model/blob/main/vignettes/wwinference.Rmd) in the [`ww-inference-model` project](https://github.com/CDCgov/ww-inference-model). This data is generated by running `notebooks/wwinference.Rmd`, which replicates the original vignette and saves the relevant data in `notebooks/data/fit/stan_data.json`.

```{python}
# | label: Import stan-data
with open("data/fit/stan_data.json","r") as file:
    stan_data = json.load(file)

```

```{python}
# | label: assign variables
gt_max = stan_data["gt_max"] #lower=1
hosp_delay_max = stan_data["hosp_delay_max"]
n_initialization_points = max(gt_max, hosp_delay_max)
i0_t_offset = 0

unobs_time = stan_data["uot"] #unobserved time
n_subpops = stan_data["n_subpops"]
state_pop = stan_data["state_pop"]
subpop_size = stan_data["subpop_size"]
norm_pop = stan_data["norm_pop"]
pop_fraction = jnp.array(subpop_size)/norm_pop

ww_ml_produced_per_day = stan_data["mwpd"]
n_ww_lab_sites = stan_data["n_ww_lab_sites"]
ww_log_lod =jnp.array(stan_data["ww_log_lod"])

n_censored = stan_data["n_censored"]
n_uncensored = stan_data["n_uncensored"]
ww_censored = jnp.array(stan_data["ww_censored"])-1  #times that the WW data is below the LOD
ww_uncensored = jnp.array(stan_data["ww_uncensored"])-1  #time that WW data is above LOD

ww_sampled_subpops = jnp.array(stan_data["ww_sampled_subpops"]) -1   # vector of unique sites in order of the sampled times
ww_sampled_times = jnp.array(stan_data["ww_sampled_times"]) -1  # a list of all of the days on which WW is sampled
ww_sampled_lab_sites = jnp.array(stan_data["ww_sampled_lab_sites"]) - 1
hosp_times = jnp.array(stan_data["hosp_times"]) -1
max_ww_sampled_days = max(stan_data["ww_sampled_times"])
lab_site_to_subpop_map = jnp.array(stan_data["lab_site_to_subpop_map"]) -1   #vector mapping the subpops to lab-site combos

data_observed_log_conc = jnp.array(stan_data["log_conc"])
data_observed_disease_hospital_admissions = jnp.array(stan_data["hosp"])
```

```{python}
# | label: set priors
eta_sd_sd = stan_data["eta_sd_sd"]
eta_sd_rv = DistributionalVariable("eta_sd", dist.TruncatedNormal(0, eta_sd_sd, low=0))

autoreg_rt_a = stan_data["autoreg_rt_a"]
autoreg_rt_b = stan_data["autoreg_rt_b"]
autoreg_rt_rv = DistributionalVariable("autoreg_rt", dist.Beta(autoreg_rt_a, autoreg_rt_b)) #autoregressive coefficient for AR process on first differences in log R(t)

r_prior_mean = stan_data["r_prior_mean"]
r_prior_sd = stan_data["r_prior_sd"]
r_logmean, r_logsd = convert_to_logmean_log_sd(r_prior_mean, r_prior_sd)

log_r_t_first_obs_rv = DistributionalVariable(
    "log_r_t_first_obs", dist.Normal(r_logmean, r_logsd)
)

offset_ref_log_r_t_prior_mean=stan_data["offset_ref_log_r_t_prior_mean"]
offset_ref_log_r_t_prior_sd = stan_data["offset_ref_log_r_t_prior_sd"]
offset_ref_log_r_t_rv = DistributionalVariable(
    "offset_ref_log_r_t", dist.Normal(
        offset_ref_log_r_t_prior_mean, offset_ref_log_r_t_prior_sd
    )
)

offset_ref_logit_i_first_obs_prior_mean = stan_data["offset_ref_logit_i_first_obs_prior_mean"]
offset_ref_logit_i_first_obs_prior_sd = stan_data["offset_ref_logit_i_first_obs_prior_sd"]
offset_ref_logit_i_first_obs_rv = DistributionalVariable(
    "offset_ref_logit_i_first_obs", dist.Normal(
        offset_ref_logit_i_first_obs_prior_mean, offset_ref_logit_i_first_obs_prior_sd
    )
)

offset_ref_initial_exp_growth_rate_prior_mean = stan_data["offset_ref_initial_exp_growth_rate_prior_mean"]
offset_ref_initial_exp_growth_rate_prior_sd = stan_data["offset_ref_initial_exp_growth_rate_prior_sd"]
offset_ref_initial_exp_growth_rate_rv = DistributionalVariable(
    "offset_ref_initial_exp_growth_rate", dist.TruncatedNormal(
        offset_ref_initial_exp_growth_rate_prior_mean, offset_ref_initial_exp_growth_rate_prior_sd,
        low=-0.01,
        high=0.01,
    )
)
```

```{python}
# | label: viral shedding parameters
viral_shedding_pars = stan_data["viral_shedding_pars"]

t_peak_mean = viral_shedding_pars[0]
t_peak_sd = viral_shedding_pars[1]
dur_shed_mean = viral_shedding_pars[4]
dur_shed_sd = viral_shedding_pars[5]

t_peak_rv = DistributionalVariable(
    "t_peak", dist.TruncatedNormal(t_peak_mean, t_peak_sd,low=0)
)

dur_shed_after_peak_rv = DistributionalVariable(
    "dur_shed_after_peak", dist.TruncatedNormal(dur_shed_mean-t_peak_mean, jnp.sqrt(dur_shed_sd**2+t_peak_sd**2), low=0)
)
max_shed_interval = dur_shed_mean + 3*dur_shed_sd
```

```{python}
infection_feedback_prior_logmean = stan_data["inf_feedback_prior_logmean"]
infection_feedback_prior_logsd = stan_data["inf_feedback_prior_logsd"]
infection_feedback_strength_rv = TransformedVariable(
    "inf_feedback",
    DistributionalVariable(
        "inf_feedback_raw",
        dist.LogNormal(infection_feedback_prior_logmean, infection_feedback_prior_logsd),
    ),
    transforms=transforms.AffineTransform(loc=0, scale=-1),
)

infection_feedback_pmf = stan_data["infection_feedback_pmf"]
infection_feedback_pmf_rv = DeterministicPMF(
    "infection_feedback_pmf", jnp.array(infection_feedback_pmf)
)

generation_interval = stan_data["generation_interval"]
generation_interval_pmf_rv = DeterministicPMF(
    "generation_interval_pmf", jnp.array(generation_interval)
)

autoreg_rt_subpop_a = stan_data["autoreg_rt_subpop_a"]
autoreg_rt_subpop_b = stan_data["autoreg_rt_subpop_b"]
autoreg_rt_subpop_rv = DistributionalVariable(
    "autoreg_rt_subpop",dist.Beta(autoreg_rt_subpop_a, autoreg_rt_subpop_b)
    )

sigma_rt_prior = stan_data["sigma_rt_prior"]
sigma_rt_rv = DistributionalVariable(
    "sigma_rt", dist.TruncatedNormal(0,sigma_rt_prior,low=0)
)# magnitude of subpopulation level R(t) heterogeneity

i_first_obs_over_n_prior_a = stan_data["i_first_obs_over_n_prior_a"]
i_first_obs_over_n_prior_b = stan_data["i_first_obs_over_n_prior_b"]
i_first_obs_over_n_rv = DistributionalVariable(
    "i_first_obs_over_n", dist.Beta(i_first_obs_over_n_prior_a, i_first_obs_over_n_prior_b)
)

sigma_i_first_obs_prior_mode = stan_data["sigma_i_first_obs_prior_mode"]
sigma_i_first_obs_prior_sd = stan_data["sigma_i_first_obs_prior_sd"]
sigma_i_first_obs_rv = DistributionalVariable(
    "sigma_i_first_obs", dist.TruncatedNormal(
        sigma_i_first_obs_prior_mode,sigma_i_first_obs_prior_sd,low=0
        )
)

sigma_initial_exp_growth_rate_prior_mode = stan_data["sigma_initial_exp_growth_rate_prior_mode"]
sigma_initial_exp_growth_rate_prior_sd = stan_data["sigma_initial_exp_growth_rate_prior_sd"]
sigma_initial_exp_growth_rate_rv = DistributionalVariable(
    "sigma_initial_exp_growth_rate", dist.TruncatedNormal(
        sigma_initial_exp_growth_rate_prior_mode,sigma_initial_exp_growth_rate_prior_sd,low=0
        )
)

mean_initial_exp_growth_rate_prior_mean = stan_data["mean_initial_exp_growth_rate_prior_mean"]
mean_initial_exp_growth_rate_prior_sd = stan_data["mean_initial_exp_growth_rate_prior_sd"]
mean_initial_exp_growth_rate_rv = DistributionalVariable(
    "mean_initial_exp_growth_rate", dist.TruncatedNormal(
        loc=mean_initial_exp_growth_rate_prior_mean,
        scale=mean_initial_exp_growth_rate_prior_sd,
        low=-0.01,
        high=0.01,
    )
)
```

```{python}
p_hosp_prior_mean = stan_data["p_hosp_prior_mean"]
p_hosp_sd_logit = stan_data["p_hosp_sd_logit"]
p_hosp_mean_rv = DistributionalVariable(
    "p_hosp_mean",
    dist.Normal(transforms.logit(p_hosp_prior_mean), p_hosp_sd_logit),
)  # logit scale

p_hosp_w_sd_sd = stan_data["p_hosp_w_sd_sd"]
p_hosp_w_sd_rv = DistributionalVariable(
    "p_hosp_w_sd", dist.TruncatedNormal(0, p_hosp_w_sd_sd, low=0)
)

autoreg_p_hosp_a = stan_data["autoreg_p_hosp_a"]
autoreg_p_hosp_b = stan_data["autoreg_p_hosp_b"]
autoreg_p_hosp_rv = DistributionalVariable(
    "autoreg_p_hosp", dist.Beta(autoreg_p_hosp_a, autoreg_p_hosp_b)
)

hosp_wday_effect_rv = TransformedVariable(
    "hosp_wday_effect",
    DistributionalVariable(
        "hosp_wday_effect_raw",
        dist.Dirichlet(jnp.array(stan_data["hosp_wday_effect_prior_alpha"])),
    ),
    transforms.AffineTransform(loc=0, scale=7),
)

inf_to_hosp_rv = DeterministicVariable(
    "inf_to_hosp", jnp.array(stan_data["inf_to_hosp"])
)

inv_sqrt_phi_prior_mean = stan_data["inv_sqrt_phi_prior_mean"]
inv_sqrt_phi_prior_sd = stan_data["inv_sqrt_phi_prior_sd"]

phi_rv = TransformedVariable(
    "phi",
    DistributionalVariable(
        "inv_sqrt_phi",
        dist.TruncatedNormal(
            loc=inv_sqrt_phi_prior_mean,
            scale=inv_sqrt_phi_prior_sd,
            low=1 / jnp.sqrt(5000),
        ),
    ),
    transforms=transforms.PowerTransform(-2),
)
```

```{python}
log10_g_prior_mean = stan_data["log10_g_prior_mean"] # mean log10 of number of genomes per infected individual
log10_g_prior_sd = stan_data["log10_g_prior_sd"]
log10_g_rv = DistributionalVariable(
    "log10_g", dist.Normal(log10_g_prior_mean, log10_g_prior_sd)
)

mode_sigma_ww_site_prior_mode = stan_data["mode_sigma_ww_site_prior_mode"]
mode_sigma_ww_site_prior_sd = stan_data["mode_sigma_ww_site_prior_sd"]
mode_sigma_ww_site_rv = DistributionalVariable(
    "mode_sigma_ww_site", dist.TruncatedNormal(mode_sigma_ww_site_prior_mode,mode_sigma_ww_site_prior_sd,low=0)
)

sd_log_sigma_ww_site_prior_mode = stan_data["sd_log_sigma_ww_site_prior_mode"]
sd_log_sigma_ww_site_prior_sd = stan_data["sd_log_sigma_ww_site_prior_sd"]
sd_log_sigma_ww_site_rv = DistributionalVariable(
    "sd_log_sigma_ww_site", dist.TruncatedNormal(sd_log_sigma_ww_site_prior_mode, sd_log_sigma_ww_site_prior_sd,low=0)
)

ww_site_mod_sd_sd = stan_data["ww_site_mod_sd_sd"]
ww_site_mod_sd_rv = DistributionalVariable(
    "ww_site_mod_sd", dist.TruncatedNormal(0,ww_site_mod_sd_sd,low=0)
)
```

```{python}
# | label: create model
my_model = ww_site_level_dynamics_model(
        state_pop,
        unobs_time,
        n_initialization_points,
        i0_t_offset,
        log_r_t_first_obs_rv,
        autoreg_rt_rv,
        eta_sd_rv,
        i_first_obs_over_n_rv,
        mean_initial_exp_growth_rate_rv,
        offset_ref_logit_i_first_obs_rv,
        offset_ref_initial_exp_growth_rate_rv,
        offset_ref_log_r_t_rv,
        generation_interval_pmf_rv,
        infection_feedback_strength_rv,
        infection_feedback_pmf_rv,
        p_hosp_mean_rv,
        p_hosp_w_sd_rv,
        autoreg_p_hosp_rv,
        hosp_wday_effect_rv,
        inf_to_hosp_rv,
        phi_rv,
        hosp_times,
        pop_fraction,
        n_subpops,
        autoreg_rt_subpop_rv,
        sigma_rt_rv,
        sigma_i_first_obs_rv,
        sigma_initial_exp_growth_rate_rv,
        t_peak_rv,
        dur_shed_after_peak_rv,
        n_ww_lab_sites,
        max_shed_interval,
        log10_g_rv,
        mode_sigma_ww_site_rv,
        sd_log_sigma_ww_site_rv,
        ww_site_mod_sd_rv,
        ww_ml_produced_per_day,
        ww_uncensored,
        ww_censored,
        ww_sampled_lab_sites,
        ww_sampled_subpops,
        ww_sampled_times,
        ww_log_lod,
        lab_site_to_subpop_map,
        max_ww_sampled_days,
        include_ww=True
)
```

Check that we can simulate from the prior predictive
```{python}
# | label: prior
n_forecast_days = 35

prior_predictive = my_model.prior_predictive(
    n_observed_disease_ed_visits_datapoints= max(len(data_observed_disease_hospital_admissions), max_ww_sampled_days) + n_forecast_days,
    numpyro_predictive_args={"num_samples": 100},
)
```

Fit the model to observed hospital admissions and wastewater data
```{python}
# | label: model fit
my_model.run(
    num_warmup=750,
    num_samples=500,
    rng_key=jax.random.key(223),
    data_observed_disease_hospital_admissions=data_observed_disease_hospital_admissions,
    data_observed_log_conc=data_observed_log_conc,
    mcmc_args=dict(num_chains=4)
)
```

Simulate the posterior predictive distribution
```{python}
# | label: posterior predictive
posterior_predictive = my_model.posterior_predictive(
    n_observed_disease_ed_visits_datapoints= max(len(data_observed_disease_hospital_admissions), max_ww_sampled_days) + n_forecast_days, is_predictive=True
)
```

```{python}
# | label: create inference data object
import arviz as az
idata = az.from_numpyro(
    my_model.mcmc,
    posterior_predictive=posterior_predictive,
    prior=prior_predictive,
)
```

```{python}
# | label: plot prior preditive
plotting.plot_predictive(idata, "observed_hospital_admissions", prior=True)
```

```{python}
# | label: plot posterior preditive
plotting.plot_predictive(idata,"observed_hospital_admissions")
```

```{python}
# | label: plot posterior predictive rt
plotting.plot_predictive(idata,'state_rt')
```

```{python}
# | label: plot posterior predictive rt by subpop
for i in range(n_subpops):
    plotting.plot_predictive(idata, 'r_subpop_t', dim_1=i)
```

```{python}
# | label: plot posterior ww conconcentration
for i in range(n_ww_lab_sites):
    plotting.plot_posterior(idata, 'site_ww_pred_log', dim_1=i)
```

```{python}
# | label: diagnostic stats
diagnostic_stats_summary = az.summary(idata)
```

```{python}
max(diagnostic_stats_summary['r_hat'])
```

We fit the model using only hospital admissions data
```{python}
# | label: create hosp only model
my_model_hosp_only_fit = ww_site_level_dynamics_model(
    state_pop,
    unobs_time,
    n_initialization_points,
    i0_t_offset,
    log_r_t_first_obs_rv,
    autoreg_rt_rv,
    eta_sd_rv,
    i_first_obs_over_n_rv,
    mean_initial_exp_growth_rate_rv,
    offset_ref_logit_i_first_obs_rv,
    offset_ref_initial_exp_growth_rate_rv,
    offset_ref_log_r_t_rv,
    generation_interval_pmf_rv,
    infection_feedback_strength_rv,
    infection_feedback_pmf_rv,
    p_hosp_mean_rv,
    p_hosp_w_sd_rv,
    autoreg_p_hosp_rv,
    hosp_wday_effect_rv,
    inf_to_hosp_rv,
    phi_rv,
    hosp_times,
    pop_fraction=1,
    n_subpops=1,
    include_ww=False,
)
```

```{python}
# | label: hosp only fit
my_model_hosp_only_fit.run(
    num_warmup=750,
    num_samples=500,
    rng_key=jax.random.key(223),
    data_observed_disease_hospital_admissions=data_observed_disease_hospital_admissions,
    mcmc_args=dict(num_chains=4)
)
```

```{python}
posterior_predictive_hosp_only = my_model_hosp_only_fit.posterior_predictive(
    n_observed_disease_ed_visits_datapoints= len(data_observed_disease_hospital_admissions) + n_forecast_days,is_predictive=True
)
```

```{python}
idata_hosp_only = az.from_numpyro(
    my_model_hosp_only_fit.mcmc,
    posterior_predictive=posterior_predictive_hosp_only,
)
```
```{python}
plotting.plot_predictive(idata_hosp_only,name='observed_hospital_admissions')
```

```{python}
plotting.plot_predictive(idata_hosp_only,'r_subpop_t')
```


```{python}
idata.to_dataframe().to_csv("data/fit/inference_data.csv", index=False)
```
