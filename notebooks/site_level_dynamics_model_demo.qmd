---
jupyter: python3
---

```{python}
import json

import numpyro
import numpyro.distributions as dist
import numpyro.distributions.transforms as transforms
from pyrenew.deterministic import DeterministicVariable, DeterministicPMF

from pyrenew.randomvariable import DistributionalVariable, TransformedVariable
from pyrenew_hew.site_level_dynamics_model import ww_site_level_dynamics_model
from pyrenew_hew.initialization import get_initialization
import jax
from numpyro.infer.initialization import init_to_sample, init_to_value
import pyrenew_hew.plotting as plotting
import matplotlib.pyplot as plt
numpyro.set_host_device_count(4)
```

```{python}
with open("data/fit/stan_data.json","r") as file:
    stan_data = json.load(file)

#helper function
from pyrenew_hew.utils import *
```

```{python}
gt_max = stan_data["gt_max"] #lower=1
hosp_delay_max = stan_data["hosp_delay_max"]
n_initialization_points = max(gt_max, hosp_delay_max)
i0_t_offset = 0 # check this later


obs_time = stan_data["ot"]# maximum time index for the hospital admissions (max number of days we could have observations)
obs_ww_time = stan_data["owt"]  #number of days of observed WW (should be roughly ot/7)
obs_hosp_time = stan_data["oht"] # number of days that we have hospital admissions observations

horizon_time = stan_data["ht"] #horizon time (nowcast + forecast time)
unobs_time = stan_data["uot"] #unobserved time before we observe hospital admissions/ WW

n_subpops = stan_data["n_subpops"]  #number of modeled subpops
state_pop = stan_data["state_pop"]
subpop_size = stan_data["subpop_size"]
norm_pop = stan_data["norm_pop"]
pop_fraction = jnp.array(subpop_size)/norm_pop

#mL of ww produced per person per day
ww_ml_produced_per_day = stan_data["mwpd"]
n_ww_lab_sites = stan_data["n_ww_lab_sites"]
ww_log_lod =jnp.array(stan_data["ww_log_lod"])  # The limit of detection in that site at that time point

n_censored = stan_data["n_censored"]
n_uncensored = stan_data["n_uncensored"]
ww_censored = jnp.array(stan_data["ww_censored"])-1  #times that the WW data is below the LOD
ww_uncensored = jnp.array(stan_data["ww_uncensored"])-1  #time that WW data is above LOD

ww_sampled_subpops = jnp.array(stan_data["ww_sampled_subpops"]) -1   # vector of unique sites in order of the sampled times
ww_sampled_times = jnp.array(stan_data["ww_sampled_times"]) -1  # a list of all of the days on which WW is sampled, mapped to corresponding subpops
ww_sampled_lab_sites = jnp.array(stan_data["ww_sampled_lab_sites"]) - 1
hosp_times = jnp.array(stan_data["hosp_times"]) -1
max_ww_sampled_days = max(stan_data["ww_sampled_times"])
lab_site_to_subpop_map = jnp.array(stan_data["lab_site_to_subpop_map"]) -1   #vector mapping the subpops to lab-site combos

data_observed_log_conc = jnp.array(stan_data["log_conc"])
data_observed_hospital_admissions = jnp.array(stan_data["hosp"])
```

```{python}
# State-leve R(t) AR + RW implementation:

eta_sd_sd = stan_data["eta_sd_sd"]
eta_sd_rv = DistributionalVariable("eta_sd", dist.TruncatedNormal(0, eta_sd_sd, low=0))

autoreg_rt_a = stan_data["autoreg_rt_a"]
autoreg_rt_b = stan_data["autoreg_rt_b"]
autoreg_rt_rv = DistributionalVariable("autoreg_rt", dist.Beta(autoreg_rt_a, autoreg_rt_b)) #autoregressive coefficient for AR process on first differences in log R(t)

r_prior_mean = stan_data["r_prior_mean"]
r_prior_sd = stan_data["r_prior_sd"]
r_logmean, r_logsd = convert_to_logmean_log_sd(r_prior_mean, r_prior_sd)

# log of state level mean R(t) in weeks
log_r_t_first_obs_rv = DistributionalVariable(
    "log_r_t_first_obs", dist.Normal(r_logmean, r_logsd)
)
```

```{python}
offset_ref_log_r_t_prior_mean=stan_data["offset_ref_log_r_t_prior_mean"]
offset_ref_log_r_t_prior_sd = stan_data["offset_ref_log_r_t_prior_sd"]
offset_ref_log_r_t_rv = DistributionalVariable(
    "offset_ref_log_r_t", dist.Normal(
        offset_ref_log_r_t_prior_mean, offset_ref_log_r_t_prior_sd
    )
)

offset_ref_logit_i_first_obs_prior_mean = stan_data["offset_ref_logit_i_first_obs_prior_mean"]
offset_ref_logit_i_first_obs_prior_sd = stan_data["offset_ref_logit_i_first_obs_prior_sd"]
offset_ref_logit_i_first_obs_rv = DistributionalVariable(
    "offset_ref_logit_i_first_obs", dist.Normal(
        offset_ref_logit_i_first_obs_prior_mean, offset_ref_logit_i_first_obs_prior_sd
    )
)

offset_ref_initial_exp_growth_rate_prior_mean = stan_data["offset_ref_initial_exp_growth_rate_prior_mean"]
offset_ref_initial_exp_growth_rate_prior_sd = stan_data["offset_ref_initial_exp_growth_rate_prior_sd"]
offset_ref_initial_exp_growth_rate_rv = DistributionalVariable(
    "offset_ref_initial_exp_growth_rate", dist.TruncatedNormal(
        offset_ref_initial_exp_growth_rate_prior_mean, offset_ref_initial_exp_growth_rate_prior_sd,
        low=-0.01,
        high=0.01,
    )
)
```

```{python}
# viral shedding parameters
viral_shedding_pars = stan_data["viral_shedding_pars"]

t_peak_mean = viral_shedding_pars[0]
t_peak_sd = viral_shedding_pars[1]
viral_peak_mean = viral_shedding_pars[2]
viral_peak_sd = viral_shedding_pars[3]
dur_shed_mean = viral_shedding_pars[4]
dur_shed_sd = viral_shedding_pars[5]

t_peak_rv = DistributionalVariable(
    "t_peak", dist.TruncatedNormal(t_peak_mean, t_peak_sd,low=0)
)

viral_peak_rv = DistributionalVariable(
    "viral_peak", dist.Normal(viral_peak_mean, viral_peak_sd)
)

dur_shed_after_peak_rv = DistributionalVariable(
    "dur_shed_after_peak", dist.TruncatedNormal(dur_shed_mean-t_peak_mean, jnp.sqrt(dur_shed_sd**2+t_peak_sd**2), low=0)
)
max_shed_interval = dur_shed_mean + 3*dur_shed_sd
```

```{python}
# Infection and site-level dynamics
infection_feedback_prior_logmean = stan_data["inf_feedback_prior_logmean"]
infection_feedback_prior_logsd = stan_data["inf_feedback_prior_logsd"]
infection_feedback_strength_rv = TransformedVariable(
    "inf_feedback",
    DistributionalVariable(
        "inf_feedback_raw",
        dist.LogNormal(infection_feedback_prior_logmean, infection_feedback_prior_logsd),
    ),
    transforms=transforms.AffineTransform(loc=0, scale=-1),
)

infection_feedback_pmf = stan_data["infection_feedback_pmf"]
infection_feedback_pmf_rv = DeterministicPMF(
    "infection_feedback_pmf", jnp.array(infection_feedback_pmf)
)

# generation interval distribution
generation_interval = stan_data["generation_interval"]
generation_interval_pmf_rv = DeterministicPMF(
    "generation_interval_pmf", jnp.array(generation_interval)
)

autoreg_rt_subpop_a = stan_data["autoreg_rt_subpop_a"]
autoreg_rt_subpop_b = stan_data["autoreg_rt_subpop_b"]
autoreg_rt_subpop_rv = DistributionalVariable(
    "autoreg_rt_subpop",dist.Beta(autoreg_rt_subpop_a, autoreg_rt_subpop_b)
    )

sigma_rt_prior = stan_data["sigma_rt_prior"]
sigma_rt_rv = DistributionalVariable(
    "sigma_rt", dist.TruncatedNormal(0,sigma_rt_prior,low=0)
)# magnitude of subpopulation level R(t) heterogeneity

i_first_obs_over_n_prior_a = stan_data["i_first_obs_over_n_prior_a"]
i_first_obs_over_n_prior_b = stan_data["i_first_obs_over_n_prior_b"]
i_first_obs_over_n_rv = DistributionalVariable(
    "i_first_obs_over_n", dist.Beta(i_first_obs_over_n_prior_a, i_first_obs_over_n_prior_b)
)

sigma_i_first_obs_prior_mode = stan_data["sigma_i_first_obs_prior_mode"]
sigma_i_first_obs_prior_sd = stan_data["sigma_i_first_obs_prior_sd"]
sigma_i_first_obs_rv = DistributionalVariable(
    "sigma_i_first_obs", dist.TruncatedNormal(
        sigma_i_first_obs_prior_mode,sigma_i_first_obs_prior_sd,low=0
        )
)

sigma_initial_exp_growth_rate_prior_mode = stan_data["sigma_initial_exp_growth_rate_prior_mode"]
sigma_initial_exp_growth_rate_prior_sd = stan_data["sigma_initial_exp_growth_rate_prior_sd"]
sigma_initial_exp_growth_rate_rv = DistributionalVariable(
    "sigma_initial_exp_growth_rate", dist.TruncatedNormal(
        sigma_initial_exp_growth_rate_prior_mode,sigma_initial_exp_growth_rate_prior_sd,low=0
        )
)

mean_initial_exp_growth_rate_prior_mean = stan_data["mean_initial_exp_growth_rate_prior_mean"]
mean_initial_exp_growth_rate_prior_sd = stan_data["mean_initial_exp_growth_rate_prior_sd"]
mean_initial_exp_growth_rate_rv = DistributionalVariable(
    "mean_initial_exp_growth_rate", dist.TruncatedNormal(
        loc=mean_initial_exp_growth_rate_prior_mean,
        scale=mean_initial_exp_growth_rate_prior_sd,
        low=-0.01,
        high=0.01,
    )
)
```

```{python}
p_hosp_prior_mean = stan_data["p_hosp_prior_mean"]
p_hosp_sd_logit = stan_data["p_hosp_sd_logit"]
p_hosp_mean_rv = DistributionalVariable(
    "p_hosp_mean",
    dist.Normal(transforms.logit(p_hosp_prior_mean), p_hosp_sd_logit),
)  # logit scale

p_hosp_w_sd_sd = stan_data["p_hosp_w_sd_sd"]
p_hosp_w_sd_rv = DistributionalVariable(
    "p_hosp_w_sd", dist.TruncatedNormal(0, p_hosp_w_sd_sd, low=0)
)

autoreg_p_hosp_a = stan_data["autoreg_p_hosp_a"]
autoreg_p_hosp_b = stan_data["autoreg_p_hosp_b"]
autoreg_p_hosp_rv = DistributionalVariable(
    "autoreg_p_hosp", dist.Beta(autoreg_p_hosp_a, autoreg_p_hosp_b)
)

hosp_wday_effect_rv = TransformedVariable(
    "hosp_wday_effect",
    DistributionalVariable(
        "hosp_wday_effect_raw",
        dist.Dirichlet(jnp.array(stan_data["hosp_wday_effect_prior_alpha"])),
    ),
    transforms.AffineTransform(loc=0, scale=7),
)

inf_to_hosp_rv = DeterministicVariable(
    "inf_to_hosp", jnp.array(stan_data["inf_to_hosp"])
)

inv_sqrt_phi_prior_mean = stan_data["inv_sqrt_phi_prior_mean"]
inv_sqrt_phi_prior_sd = stan_data["inv_sqrt_phi_prior_sd"]

phi_rv = TransformedVariable(
    "phi",
    DistributionalVariable(
        "inv_sqrt_phi",
        dist.TruncatedNormal(
            loc=inv_sqrt_phi_prior_mean,
            scale=inv_sqrt_phi_prior_sd,
            low=1 / jnp.sqrt(5000),
        ),
    ),
    transforms=transforms.PowerTransform(-2),
)
```

```{python}
log10_g_prior_mean = stan_data["log10_g_prior_mean"] # mean log10 of number of genomes per infected individual
log10_g_prior_sd = stan_data["log10_g_prior_sd"]
log10_g_rv = DistributionalVariable(
    "log10_g", dist.Normal(log10_g_prior_mean, log10_g_prior_sd)
)

mode_sigma_ww_site_prior_mode = stan_data["mode_sigma_ww_site_prior_mode"]
mode_sigma_ww_site_prior_sd = stan_data["mode_sigma_ww_site_prior_sd"]
mode_sigma_ww_site_rv = DistributionalVariable(
    "mode_sigma_ww_site", dist.TruncatedNormal(mode_sigma_ww_site_prior_mode,mode_sigma_ww_site_prior_sd,low=0)
)

sd_log_sigma_ww_site_prior_mode = stan_data["sd_log_sigma_ww_site_prior_mode"]
sd_log_sigma_ww_site_prior_sd = stan_data["sd_log_sigma_ww_site_prior_sd"]
sd_log_sigma_ww_site_rv = DistributionalVariable(
    "sd_log_sigma_ww_site", dist.TruncatedNormal(sd_log_sigma_ww_site_prior_mode, sd_log_sigma_ww_site_prior_sd,low=0)
)

ww_site_mod_sd_sd = stan_data["ww_site_mod_sd_sd"]
ww_site_mod_sd_rv = DistributionalVariable(
    "ww_site_mod_sd", dist.TruncatedNormal(0,ww_site_mod_sd_sd,low=0)
)
```

```{python}
my_model = ww_site_level_dynamics_model(
    state_pop,
    n_subpops,
    n_ww_lab_sites,
    unobs_time,
    n_initialization_points,
    max_shed_interval,
    i0_t_offset,
    log_r_t_first_obs_rv,
    autoreg_rt_rv,
    eta_sd_rv,
    t_peak_rv,
    dur_shed_after_peak_rv,
    autoreg_rt_subpop_rv,
    sigma_rt_rv,
    i_first_obs_over_n_rv,
    sigma_i_first_obs_rv,
    sigma_initial_exp_growth_rate_rv,
    mean_initial_exp_growth_rate_rv,
    offset_ref_logit_i_first_obs_rv,
    offset_ref_initial_exp_growth_rate_rv,
    offset_ref_log_r_t_rv,
    generation_interval_pmf_rv,
    infection_feedback_strength_rv,
    infection_feedback_pmf_rv,
    p_hosp_mean_rv,
    p_hosp_w_sd_rv,
    autoreg_p_hosp_rv,
    hosp_wday_effect_rv,
    inf_to_hosp_rv,
    log10_g_rv,
    mode_sigma_ww_site_rv,
    sd_log_sigma_ww_site_rv,
    ww_site_mod_sd_rv,
    phi_rv,
    ww_ml_produced_per_day,
    pop_fraction,
    ww_uncensored,
    ww_censored,
    ww_sampled_lab_sites,
    ww_sampled_subpops,
    ww_sampled_times,
    ww_log_lod,
    lab_site_to_subpop_map,
    hosp_times,
    max_ww_sampled_days,
)
```

```{python}
n_forecast_days = 35

prior_predictive = my_model.prior_predictive(
    n_datapoints= max(len(data_observed_hospital_admissions), max_ww_sampled_days) + n_forecast_days,
    numpyro_predictive_args={"num_samples": 100},
)
```

```{python}
my_model.run(
    num_warmup=500,
    num_samples=100,
    rng_key=jax.random.key(223),
    data_observed_hospital_admissions=data_observed_hospital_admissions,
    data_observed_log_conc=data_observed_log_conc,
    mcmc_args=dict(num_chains=4),
    nuts_args=dict(init_strategy=init_to_sample)
)
```

```{python}
posterior_predictive = my_model.posterior_predictive(
    n_datapoints= max(len(data_observed_hospital_admissions), max_ww_sampled_days) + n_forecast_days,
)
```

We can use initial values set in the stan code by using `init_strategy = init_to_value` and use the following to generate initial values 
`init_vals = get_initialization(stan_data,stdev=0.01,rng_key=jax.random.PRNGKey(0))`

```{python}
import arviz as az
idata = az.from_numpyro(
    my_model.mcmc,
    posterior_predictive=posterior_predictive,
    prior=prior_predictive,
)
```

```{python}
idata
```

```{python}
plotting.plot_predictive(idata, prior=True)
```

```{python}
plotting.plot_predictive(idata)
```

```{python}
plotting.plot_posterior(idata,'state_rt')
```

```{python}
x_data = idata.posterior_predictive['state_rt_dim_0']
y_data = idata.posterior_predictive['state_rt']

def compute_eti(dataset, eti_prob):
    eti_bdry = dataset.quantile(
        ((1 - eti_prob) / 2, 1 / 2 + eti_prob / 2), dim=("chain", "draw")
    )
    return eti_bdry.values.T
fig, axes = plt.subplots(figsize=(6, 5))
az.plot_hdi(
    x_data,
    hdi_data=compute_eti(y_data, 0.9),
    color="C0",
    smooth=False,
    fill_kwargs={"alpha": 0.3},
    ax=axes,
)

az.plot_hdi(
    x_data,
    hdi_data=compute_eti(y_data, 0.5),
    color="C0",
    smooth=False,
    fill_kwargs={"alpha": 0.6},
    ax=axes,
)

# Add median of the posterior to the figure
median_ts = y_data.median(dim=["chain", "draw"])

plt.plot(
    x_data,
    median_ts,
    color="C0",
    label="Median",
)
```

```{python}
for i in range(n_subpops):
    plotting.plot_posterior(idata, 'r_subpop_t', dim_1=i)
```

```{python}
for i in range(n_ww_lab_sites):
    plotting.plot_posterior(idata, 'site_ww_pred_log', dim_1=i)
```

```{python}
diagnostic_stats_summary = az.summary(idata)
```

```{python}
max(diagnostic_stats_summary['r_hat'])
```

```{python}
min(diagnostic_stats_summary['ess_bulk'])
```

```{python}
min(diagnostic_stats_summary['ess_tail'])
```


