"""
Process EpiAutoGP forecast outputs to match the format expected by plotting functions.

This module provides minimal processing to convert Julia output into the format
expected by R plotting functions (samples.parquet and ci.parquet).
"""

from pathlib import Path

import polars as pl


def calculate_credible_intervals(
    samples: pl.DataFrame,
    ci_widths: list[float] = [0.5, 0.8, 0.95],
) -> pl.DataFrame:
    """
    Calculate median and credible intervals from posterior samples.

    Parameters
    ----------
    samples : pl.DataFrame
        Samples with .draw, .value, and grouping columns
    ci_widths : list[float]
        Widths of credible intervals to compute (e.g., 0.5 = 50% interval)

    Returns
    -------
    pl.DataFrame
        Credible intervals with columns for median, .lower, .upper at each width

    Notes
    -----
    The output format matches R's ggdist::median_qi output, with separate rows
    for each credible interval width. For example, if ci_widths=[0.5, 0.95],
    each group will have two rows: one for the 50% CI and one for the 95% CI.
    """
    # Group by everything except .draw and .value
    group_cols = [c for c in samples.columns if c not in [".draw", ".value"]]

    # Calculate quantiles for each CI width
    quantile_exprs = []
    for width in ci_widths:
        lower_q = (1 - width) / 2
        upper_q = 1 - lower_q

        quantile_exprs.extend(
            [
                pl.col(".value").quantile(lower_q).alias(f".lower_{width}"),
                pl.col(".value").quantile(upper_q).alias(f".upper_{width}"),
            ]
        )

    ci = samples.group_by(group_cols).agg(
        [
            pl.col(".value").median().alias(".value"),
            *quantile_exprs,
        ]
    )

    # Create separate rows for each width (matching R's ggdist::median_qi output)
    ci_list = []
    for width in ci_widths:
        ci_width = ci.select(
            [
                *group_cols,
                pl.col(".value"),
                pl.col(f".lower_{width}").alias(".lower"),
                pl.col(f".upper_{width}").alias(".upper"),
                pl.lit(width).alias(".width"),
            ]
        )
        ci_list.append(ci_width)

    return pl.concat(ci_list, how="vertical")


def process_epiautogp_forecast(
    model_run_dir: Path | str,
    model_name: str,
    target: str,
    frequency: str,
    ci_widths: list[float] = [0.5, 0.8, 0.95],
    save: bool = True,
) -> dict[str, pl.DataFrame]:
    """
    Process EpiAutoGP forecast outputs to create samples and credible intervals.

    Reads the Julia-generated parquet file, adds required metadata columns,
    calculates credible intervals, and saves outputs in the format expected
    by R plotting functions.

    Parameters
    ----------
    model_run_dir : Path | str
        Directory containing model runs
    model_name : str
        Name of the EpiAutoGP model directory
    target : str
        Target type ("nhsn" or "nssp")
    frequency : str
        Forecast frequency ("daily" or "epiweekly")
    ci_widths : list[float]
        Widths of credible intervals to compute
    save : bool
        Whether to save the output DataFrames as parquet files

    Returns
    -------
    dict[str, pl.DataFrame]
        Dictionary with keys:
        - "samples": Forecast samples with metadata
        - "ci": Credible intervals

    Raises
    ------
    FileNotFoundError
        If the EpiAutoGP forecast parquet file doesn't exist

    Notes
    -----
    The function reads Julia-generated parquet files with the naming convention:
    `{frequency}_epiautogp_samples_{suffix}.parquet` where suffix is:
    - "h" for NHSN hospital admissions
    - "e" for NSSP emergency department visits

    The aggregated_numerator and aggregated_denominator flags are set to False
    and None respectively because EpiAutoGP produces forecasts directly at the
    specified frequency without aggregation from daily to epiweekly.
    """
    model_dir = Path(model_run_dir) / model_name

    # Map target to file suffix (matching Julia's DEFAULT_TARGET_LETTER)
    target_suffix = {
        "nhsn": "h",  # hospital admissions
        "nssp": "e",  # emergency department visits
    }
    suffix = target_suffix.get(target, "e")  # default to "e" if unknown

    # Read EpiAutoGP forecast samples (generated by Julia)
    forecast_samples = pl.read_parquet(
        model_dir / f"{frequency}_epiautogp_samples_{suffix}.parquet"
    )

    # Ensure date column is proper date type (Julia saves as string)
    if forecast_samples.schema["date"] != pl.Date:
        forecast_samples = forecast_samples.with_columns(pl.col("date").str.to_date())

    # Add aggregation metadata columns for compatibility with plotting functions
    # EpiAutoGP produces epiweekly forecasts, so aggregated_numerator = False
    # (not aggregated from daily to epiweekly by the pipeline)
    model_samples_tidy = forecast_samples.with_columns(
        [
            pl.lit(False).alias("aggregated_numerator"),
            pl.lit(None).cast(pl.Boolean).alias("aggregated_denominator"),
        ]
    )

    # Calculate credible intervals
    ci = calculate_credible_intervals(model_samples_tidy, ci_widths=ci_widths)

    result = {
        "samples": model_samples_tidy,
        "ci": ci,
    }

    # Save outputs in the format expected by R plotting
    if save:
        save_dir = model_dir

        result["samples"].write_parquet(save_dir / "samples.parquet")
        result["ci"].write_parquet(save_dir / "ci.parquet")

    return result
